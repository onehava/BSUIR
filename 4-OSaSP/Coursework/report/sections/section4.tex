\section{Разработка программных модулей}

Как уже было отмечено в разделе \ref{system-design},
архитектура драйвера, реализованного в рамках данной работы,
не предполагает модульной архитектуры, а потому в качестве модулей
рассматриваются группы функций, выполняющих схожие задачи.

\subsection{Разработка группы вспомогательных функций}

В подразделе \ref{utility-group-design} упоминалось, что функции из данной
группы отвечают за выделение и освобождение памяти полей структуры \texttt{usbkeyboard},
поэтому, для дальнейшего обсуждения их реализации, необходимо привести ее определение:
\begin{verbatim}
struct usbkeyboard {
    struct input_dev* dev;
    struct usb_device* usbdev;

    struct urb* irq;
    struct urb* led;

    struct usb_ctrlrequest* creq;

    char name[KBD_NAME_MAX];
    char phys[KBD_PHYS_MAX];

    unsigned char prev_presses[8];
    unsigned char* presses;

    unsigned char curr_leds;
    unsigned char* leds;    

    dma_addr_t presses_dma;
    dma_addr_t leds_dma;

    bool leds_urb_submitted;
    spinlock_t leds_lock;
};
\end{verbatim}

Поля \texttt{dev} и \texttt{usbdev} выполняют указание на системные структуры
устройства ввода и устройства последовательной шины.

В свою очередь \texttt{irq} и \texttt{led} указывают на URB, первый из которых
отвечает за получение состояния нажатия клавиш, 
а второй -- за установку состояния светодиодов.

Символические массивы \texttt{name} и \texttt{phys} хранят название устройства
и его физический путь (в представлении топологии шины).

Массив \texttt{prev\_presses} хранит предыдущее состояние нажатий,
а указатель \texttt{presses} ссылается на память, используемую для хранения
получаемого от устройства состояния нажатий.

Поля \texttt{curr\_leds} и \texttt{leds} имеют назначение, аналогичное
предыдущим, за тем лишь исключением, что размер переменной предыдущего состояния
и размер памяти текущего состояния составляет один байт, что соответствует 
сведениям, представленным в таблице \ref{leds}.

Самыми интересными с точки зрения взаимодействия с памятью являются
поля \texttt{presses\_dma} и \texttt{leds\_dma}.
Данные поля хранят адрес прямого доступа к памяти (DMA),
механизм которого используется для совместного доступа к памяти
как со стороны процессора, так и со стороны самого устройства.
Выделение памяти для \texttt{presses} и \texttt{leds} осуществляется
при помощи функции \texttt{usb\_alloc\_coherent}
\footnote{
    coherent, когерентный, в данном контексте означает
    <<согласованный>>, предоставляющий совместный доступ.
},
одним из аргументов которой является \texttt{dma\_addr\_t*}.
В результате вызова функции возвращается указатель на буфер в CPU-пространства,
согласованный с DMA, а по адресу \texttt{dma\_addr\_t*} возвращается DMA-адрес буфера.
Чаще всего данный подход используется для того,
чтобы устройство на шине могло записывать данные в оперативную память
напрямую, не прерывая вычисления процессора.
Подробнее о технологии прямого доступа к памяти,
а также о предоставляемых операционной системой Linux возможностях, 
можно прочитать в источниках \cite{dma, ldd3}.

Поле \texttt{creq} содержит в себе структуру управляющего
запроса, используемого для отправки запроса на изменение состояния светодиодов 
устройства клавиатуры.

Оставшиеся поля \texttt{leds\_usb\_submitted} и \texttt{leds\_lock}
отвечают за синхронизацию группы управления состоянием
светодиодов, и будут подробно рассмотрены в подразделе \ref{dev-leds-group}.

\subsection{Разработка группы контрольных событий}

Функции данной группы отвечают за начальную инициализацию 
данных драйвера для нового интерфейса устройства,
и инициализируют некоторые поля структуры \texttt{usbkeyboard},
не относящиеся к чистому выделению памяти,
например, поля \texttt{dev}, \texttt{usbdev}, получаемые
путем приведения системной структуры интерфейса и регистрации
устройства ввода, а также
\texttt{name}, \texttt{phys}, \texttt{leds\_urb\_submitted} и \texttt{leds\_lock},
требующих инициализации и не требующих выделения памяти для поля структуры.

Как уже было упомянуто ранее, данные для каждого устройства не хранятся в памяти самого драйвера
в виде массива структур \texttt{usbkeyboard}, а передаются в виде контекста \texttt{urb} и данных \texttt{input\_dev},
поэтому предыдущая группа функций называется \emph{вспомогательной},
а функции из данной группы можно считать функциями инициализации и деинициализации
данных драйвера для устройства.

Функции \texttt{usbkeyboard\_open} и \texttt{usbkeyboard\_close} обрабатывают события
открытия и закрытия устройства ввода, и отвечают за регистрацию и прекращение
обработки нажатий клавиш клавиатуры, 
используя функции \texttt{usb\_submit\_urb} и \texttt{usb\_kill\_urb}
соответственно.

\subsection{Разработка группы управления нажатиями клавиш}

Данная группа содержит единственную функцию обратного вызова
\texttt{usbkeyboard\_irq}, 
которая вызывается при возвращении устройством состояния
нажатий клавиш. Как уже было сказано в теоретической части,
для определения нажатых и отпущенных клавиш очередь текущих нажатий
сравнивается с очередью предыдущих нажатий посредством поиска вхождения, 
а байт состояния клавиш-модификаторов сравнивается простыми 
побитовыми операциями. 

Подсистема ввода уведомляется об изменении статуса
клавиши посредством вызова системной функции \texttt{input\_report\_key}.

Для приведения usb-кодов в raw-коды используется таблица
преобразования, представленная массивом \texttt{usbkeyboard\_keycodes}.

В случае возникновения ошибки, не связанной с состоянием
передачи, функция выполняет повторную регистрацию \texttt{irq}.

Блок-схема алгоритма функции обработчика статуса нажатий клавиатуры представлена
в приложении \ref{scheme-app}.

\subsection{Разработка группы управления состоянием светодиодов} \label{dev-leds-group}

Данная группа представлена функциями 
двумя функциями и представляет
особый интерес с точки зрения технической реализации.

Дело в том, что согласно спецификации Linux USB API \cite{usbapi},
статус выполнения URB является действительным лишь тогда,
когда был совершен обратный вызов, т.е. тогда, когда блок запроса
был выполнен.

Ожидаемое от статуса URB поведение не выполняется в ситуации
согласования обратных
вызовов \texttt{usbkeyboard\_led} и \texttt{usbkeyboard\_event},
необходимого для совместного использования данных о светодиодах,
хранящихся в структуре \texttt{usbkeyboard} \cite{verification}.

Решением данной проблемы является введение логической переменной
\texttt{leds\_urb\_submitted}, положительное значение которой означает
наличие активного управляющего запроса в данный момент,
а также спинлоком \texttt{leds\_lock}, используемого для входа
в критические секции обратных вызовов с отключением обработки
прерываний на время обслуживания критической секции кода.

Для входа в критическую секцию используется синхронизация
на спинлоке с помощью макроса \texttt{spin\_lock\_irqsave},
для выхода из критической секции используется макром \texttt{spin\_lock\_irqrestore}.
Данные макросы используются в паре для отключения обработки
прерываний на время нахождения в критической секции с возможностью последующего восстановления.

Алгоритм синхронизации для функции \texttt{usbkeyboard\_event}:
\begin{enumerate}
    \item Вход в критическую секцию;
    \item Если условие \texttt{leds\_urb\_submitted} истинно,
          выход из критической секции с завершением выполнения;
    \item Если новое состояние совпадает с предыдущим,
          выход из критической секции с завершением выполнения;
    \item Сохраняется текущее состояние;
    \item Регистрируется запрос с новым состоянием;
    \item Если не удалось зарегистрировать запрос,
          выход из критической секции с завершением выполнения;
    \item Устанавливается истинное значение для
          \texttt{leds\_urb\_submitted};
    \item Выход из критической секции;
    \item Конец алгоритма.
\end{enumerate}

Алгоритм синхронизации для функции \texttt{usbkeyboard\_led}:
\begin{enumerate}
    \item Вход в критическую секцию;
    \item Если новое состояние совпадает с предыдущим,
          устанавливается ложное значение для
          \texttt{leds\_urb\_submitted} и совершается
          выход из критической секции с завершением выполнения;
    \item Сохраняется текущее состояние;
    \item Регистрируется запрос с новым состоянием;
    \item Если не удалось зарегистрировать запрос,
          устанавливается ложное значение для
          \texttt{leds\_urb\_submitted} и совершается  
          выход из критической секции с завершением выполнения;
    \item Выход из критической секции;
    \item Конец алгоритма.
\end{enumerate}

Как видно из представленных выше алгоритмов, оба обратных вызова
используют спинлок для согласования доступа к данным о состоянии
светодиодов клавиатуры, а логическая переменная используется для
индикации состояния активного запроса на изменение этого состояния.
Помимо этого, в функции \texttt{usbkeyboard\_led} присутствует
повторная отправка запроса в случае, когда данные, хранящиеся в буфере
текущего состояния светодиодов, не совпадают с данными, восстановленными
из контекста обработанного блока.