# Ответы на экзамен по ПнаЯВУ

## Предисловие

Данный документ является результатом систематизации знаний по дисциплине "Программирование на языках высокого уровня" и содержит в себе ответы на вопросы к экзамену зимней сессии 2023 года.

---

## 001 Абстрактные типы данных


_Абстрактные типы данных_ - это набор, включающий в себя данные и выполняемые над ним операции.

## 002 Базовые принципы объектно-ориентированного программирования

_Абстракция (данных)_ - это выделения набора наиболее значимых характеристик объекта, доступных программе.

_Инкапсуляция_ - это свойство системы, позволяющее объединить данные и поведение в единый компонент, разделяя его на две обособленные части - интерфейс и реализацию.

_Наследование_ - это свойство системы, позволяющее абстрактному типу данных наследовать данные и функциональность некоторого существующего типа, тем самым обеспечивая повторное использование компонентов программного обеспечения.

_Полиморфизм (подтипов)_ - это свойство системы, позволяющее использовать объекте с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

_Обмен сообщениями_ - это способ передачи управления объекту с помощью методов.

## 003 Основные достоинства языка C++

- Поддержка ООП.

- Высокая скорость вследствие низкой стоимости абстракций стандартной библиотеки.

- Возможность работы с данными как на низком, так и на высоком уровне.

- Развивающийся стандарт языка, а также сторонние библиотеки от сообщества.

- Высокая обратная совместимость с языком C.

- Повсеместная распространенность и универсальность.

## 004 Особенности языка C++

Главной особенностью языка C++ является то, что он сочетает в себе свойства как
высокоуровневых, так и низкоуровневых языков.

Ниже будут представлены некоторые синтаксические и семантические особенности
языка C++.

### Тернарный оператор

Условный оператор может возвращать не только _rvalue_, но и _lvalue_:

```c++
(a == 0 ? a : b) = 1;
```

Данная запись эквивалентна следующей:
```c++
if(a == 0) a = 1; else b = 0;
```

### Объявление экземпляров классов и функций

В _init_ части цикла _for_ можно объявлять не только переменные, но также классы и функции:
```c++
for(struct {int x; int y;} loop = {1; 1}; ...; ...){...}
```
### Ассоциативность оператора индексации

Оператор `operator[]`, применяемый к массиву `A` аналогичен записи `*(A + i)`, что может быть переписано как `*(i + A)`,
что синонимично `8[A]`:
```c++
#include <iostream>

int main(){
    int A[8] = {1, 2, 3, 4, 5, 6, 7, 8};
    std::cout << 5[A];
}
```

Результат выполнения программы:
```
6
```

## 005 Ключевые слова

_Ключевые слова_ - это предварительно определенные зарезервированные идентификаторы, имеющие специальные значения.

Ключевые слова нельзя использовать в качестве идентификаторов.

C++ также определяет специальные идентификаторы: `override`, `final`, `import` и `module`. Они имеют особое значение при использовании в определенных контекстах, но не зарезервированы.

## 006 Константы и переменные

_Константа_ - это величина, которая при выполнении программы остается неизменной.

_Переменная_ - это ячейка памяти для временного хранения данных.

Для объявления _констант_ используется модификатор памяти `const`.

Пример:
```c++
const int x = 10; // объявление константы `x`

unsigned long number = 123; // объявление переменной `number`
```

## 007 Операции

Под _операцией_ понимается действие _оператора_ языка на некоторые значения.

По количеству операндов операции различаются на:
- унарные (один операнд);
- бинарные (два операнда);
- тернарные (три операнда).

Существуют следующие типы операций:
- операции присваивания;
- арифметические операции;
- логические операции;
- бинарные операции;
- операции сравнения;
- условная операция.

## 008 Типы данных

В языке C++ можно выделить следующие основные типы данных:
1. логический тип;
2. целочисленные типы;
3. числа с плавающей запятой;
4. строковые типы;
5. указатели;
6. абстрактные типы данных.

### Логический тип

Под _логическим_ типом в языке C++ понимают тип данных `bool`.

Размер типа данных `bool` составляет 1 байт и представлен двумя значениями `true` (истина) и `false` (ложь).

Для логического типа данных существуют специальные _логические_ операции, однако на уровне языка он воспринимается как целочисленный тип.

### Целочислкенные типы

В языке C++ существуют следующие целочисленные типы:
`char (1 байт)`, `short (2 байт)`, `long (4 байт)`, `long long (8 байт)`.

При помощи ключевых слов `signed` и `unsigned` целочисленный тип может быть определен как знаковый и беззнаковый соответственно. 

По умолчанию все целочисленные типы являются знаковыми.

### Числа с плавающей запятой

В языке C++ существуют следующие типы для чисел с плавающей запятой:
`float (4 байт)`, `double (8 байт)`, `long double`.

Типу `float` соответствуют числа с плавающей запятой одинарной точности, `double` - числа с плавающей запятой двойной точности.

Размер и диапазон значения `long double` не определен стандартом и зависит от реализации компилятора.

### Строковые типы

Для представления строк в языке C++ используются абстракции стандартной библиотеки наподобие `std::string`, однако под строковым типом понимают строки, доставшиеся C++ от языка C.

Именно по этой причине в языке C++ существует присваивание строкового литерала переменной типа `const char*`.

### Указатели

Еще одним низкоуровневым типом данных, доставшимся языку С++ от языка С являются _указатели_.

Под указателем понимают переменную, которая хранит адрес памяти, на которую она указывает.

Пример объявления указателя:
```c++
const char* x = "some text"; // указатель на строковый литерал

void (*func_ptr)(int) = func; // указатель на функцию void(int)
```

Примечание 1: для указания на область памяти без приведения типа используется указатель вида `void*`.

Примечание 2: для указания на функцию, не содержащую аргументов, в её параметрах необходимо написать `void`.

### Абстрактные типы данных

Под _абстрактными типами данных_ понимают составные типы, определяемые самим пользователем.

К таким типам относятся _классы_, _структуры_, _объединения_ и _перечисления_.

Ниже представлен пример объявления абстрактного типа данных _Point_, представляющего собой точку на плоскости:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);
    
    double x();
    double y();
    double distance(const Point& other);

private:
    double m_x;
    double m_y;
}
```

## 009 Передача аргументов в функцию по умолчанию

_Передача аргументов в функцию по умолчанию_ - это механизм, позволяющий опустить аргумент функции, полагая, что для него существует некоторое _определенное по умолчанию_ значение.

Общая форма объявления функции, которая использует аргументы по умолчанию:

```c++
type func_name(type1 v1 = val1, ..., typeN vN = valN){
    // something
}
```

_Примечание._ Аргументы по умолчанию должны следовать после аргументов без предопределенного значения.

## 010 Простейший ввод и вывод

Стандартный ввод и вывод в языке C++ реализован с помощью потоков ввода-вывода.

Поток ввода по умолчанию: `std::cin`.

Поток вывода по умолчанию: `std::cout`. 

## 011 Объект cin

Глобальный объект `cin` отвечает за ввод из буфера потока,
связанного со стандартным потоком ввода `stdcin` языка С.

_Примечание._ Если не вызван `sync_with_stdio(false)`, можно безопасно одновременно обращаться к этим объектам из нескольких потоков как для формативного, так и неформативного ввода.

## 012 Объект cout

Глобальные объект `cout` отвечает за вывод в буфер потока, связанного со стандартным потоком вывода `stdout` языка С.

_Примечание._ Если не вызван `sync_with_stdio(false)`, можно безопасно одновременно обращаться к этим объектам из нескольких потоков как для формативного, так и неформативного ввода.

## 013 Манипуляторы ввода/вывода

Манипуляторы ввода/вывода реализованы в стандартной библиотеке `<iomanip>`.

Манипуляторы применяются к потоку с помощью оператора `operator>>` и устанавливают соответствующие их действию флаги.

Основные манипуляторы:
1. `boolalpha`, `noboolalpha` - формат вывода логического типа;
2. `showbase`, `noshowbase` - отображение системы счисления чисел;
3. `showpoint`, `noshowpoint` - отображение незначащих нулей;
4. `showpos`, `noshowpos` - отображение знака числа;
5. `unitbuf`, `nounitbuf` - очистка буфера после каждого взаимодействия;
6. `internal`, `left`, `right` - расположение числа в области вывода;
7. `dec`, `hex`, `oct` - система счисления числа;
8. `fixed`, `scientific`, `hexfloat`, `defautfloat` - представление числа;
9. `ws` - игнорировать лидирующие пробелы;
1. `ends` - вывод символа-терминала;
2. `flush` - очистка буфера;
3. `endl` - вывод переноса строки и очистка буфера;
4. `setbase` - установка определенной системы счисления;
5. `setfill` - установка символа-заполнителя;
6. `setprecision` - установка точности числа с плавающей запятой;
7. `setw` - установка ширины поля вывода;
8. `quoted` - режим цитирования для ввода строки.

## 014 Операторы для динамического выделения и освобождения памяти (new и delete)

Оператор `new` выделяет память, в случае переполнения кучи вызывает std::bad_alloc.

Оператор `delete` очищает выделенную память.

Пример программы с динамическим выделением и освобождением памяти:
```c++
int main(){
    int* array = new int[10];
    delete array;
}
```

## 015 Объекты

_Объект_ - это сущность в цифровом пространстве, появляющаяся при создании экземпляра класса, обладающая состоянием и поведением, имеющая поля и методы.

## 016 Понятие класса

_Класс_ - это модель для создания объектов определенного типа, описывающая их структуру и определяющая методы для работы с этими объектами.

## 017 Конструктор с параметрами, конструктор по умолчанию

Конструктор по умолчанию `Clazz() = default`
создает экземпляр класса с полями по умолчанию.

Конструктор с параметрами `Clazz(...)` создает экземпляр класса, для инициализации полей которого использует аргументы, переданные
пользователем.

## 018 Деструктор
 
Декструктор `~Clazz()` вызывается при удалении объекта (в результате вызова оператора delete() либо выхода переменной объекта из области видимости).

## 019 Конструктор копирования

Конструктор копирования `Clazz(const &Clazz)` выполняет создание копии объекта, переданного по константной ссылке.

Вызывается:
- при объявлении объекта с одновременной инициализацией данными другого объекта через operator=();
- когда необходимо передать объект в функцию как параметр-значение (копию);
- когда нужно вернуть объект из функции по значению (полная копия объекта).

## 020 Конструктор explicit

Ключевое слово `explicit` определяет конструктор, который не может использоваться для _неявного_ преобразования типов.

Пример:
```c++
class Box {
public:
    explicit Box(int v);

private:
    const int m_v;
}

int main(){
    Box box = 10; // данный код вызовет ошибку
    Box box = static_cast<Box>(10);
}
```

_Примечание._ В общем случае `explicit` запрещает неявное приведение типов для всех методов класса, например, его использование для операторов приведения типа запрещает приводить объект класса к данному типу неявно:
```c++
class Box {
public:
    explicit Box(int v);
    explicit operator int();

private:
    const int m_v;
}

int main(){
    Box box = Box(10);

    int number = box; // данный код вызовет ошибку
    int number = static_cast<int>(box); 
}
```

## 021 Указатель this

Указатель `this` содержит адрес на объект данного класса.

Чаще всего используется для внутренного обращения к полю тогда, когда возникает конфликт имен локальной переменной и имени данного поля.

## 022 Встроенные функции (спецификатор inline)

Спецификатор `inline` указывает компилятору заменить код в определении функции для каждого экземпляра вызова функции.

## 023 Организация внешнего доступа к локальным компонентам класса (спецификатор friend)

Спецификатор `friend` обеспечивает внешний доступ к внутренним полям экземпляра класса.

Возможны _friend-классы_, а также _friend-функции_.

Чаще всего спецификатор `friend` использется для объявления дружественных бинарных операторов:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);

    friend ostream& operator>>(ostream& os, const Point& point);
}
```

## 024 Дружественные классы

Как уже и было сказано _в пункте 23_,
_friend-класс_ получает доступ ко всем полям данного класса.

Пример:
```c++
class Point {
public:
    Point(double x, double y);
    Point(const Point& other);


private:
    // Класс Canvas может обращаться к полям m_x, m_y класса Point 
    friend class Canvas;
    const double m_x , m_y;
}
```

## 025 Вложенные классы

_Вложенным классом_ называется класс, определенный внутри данного класса.

Действует по отношению к полям внешного класса также, как и _friend-класс_, но определяется в пространстве имен данного класса и можеть быть скрыт извне с помощью модификатора доступа private.

Пример:
```c++
class vector {
public:
    ...

private:
    ...
    // Классы node и iterator являются вложенными классами vector
    class node;
    class iterator;
}
```

## 026 Static-члены (данные) класса

Ключевое слово `static` является указанием на время жизни объекта.

После объявления _static-переменной_ она продолжает существовать по конца работы программы, даже если _static-переменная_ вышла из области видимости.

Ключевое слово `static` по отношению к полям класса определяет переменную, принадлежащую не её экземплярам, а имени класса в целом.

## 027 Компоненты-функции static и const

Описание модификатора `static` по отношению к компонент-функциям описано в _пункте 26_.

Модификатор `static` определяет метод класса не как метод его экземпляра, а как функцию, определенную в его имени.

Модификатор `const` после сигнатуры компонент-функции указывает на неизменяемость внутренного состояния объекта этим методом 

_Примечание._ Модификатор `const` не запрещает изменять поля с модификаторами `mutable` и `static`.

## 028 Proxy-классы

_Proxy-класс (паттерн 'Заместитель')_ - это класс, который предоставляет модифицированный интерфейс другого класса.

_Proxy-паттерн_ используется для создания посредника, который действует как интерфейс по отношению к другому ресурсу.

В отличие от _Adapter-паттерна_ не расширяет интерфейс, а оставляет его прежним.

Пример:
```c++
class Abstract {
public:
    virtual void process() = 0;
    virtual ~Abstract() = 0;
}

class Impl : public Abstract {
    Impl(){
        // загрузка очень больших данных
    }

    ~Impl() override {
        // выгрузка очень больших данных
    }

    void process() override {
        // обработка очень больших данных
    }
}

class Proxy : public Abstract {
public:
    Proxy(){}
    ~Proxy() override {}

    void process() override {
        if(!m_abstract){
            this->m_abstract = new Impl();
        }
        m_abstract.process();
    }

private:
    Abstract* m_abstract = nullptr;
}

int main(){
    // создание объекта не повлечет загрузку очень больших данных
    Abstract abstract = Proxy();
    // загрузка очень больших данных произойдет здесь
    abstract.process();
    // начиная с этого момента данные считаются загруженными
    abstract.process();
}
```

## 029 Ссылки

_Ссылка_ - это переменная, адресующая существующий в памяти объект.

Из определения ссылок следует, что не существует _нулевых ссылок_, а сама ссылка должна быть инициализирована.

_Const-ссылка_ - это ссылка на константу, имеет вид `const T &name`, предоставляет доступ только для чтения.

_Lvalue-ссылки_ - это стандартная ссылка на объект.

_Rvalue-ссылки_ - это разновидность ссылок, 
которая появилась в C++11.

_Rvalue-ссылка_ определяется как `T &&rv = init_expression` и используется в _move-семантике_.

## 030 Параметры-ссылки

_Параметры-ссылки_ используются для передачи в функцию значений по ссылке.

Пример функции, использующей ссылки в качестве параметров:
```c++
std::string concat(const std::string& a, const std::string& b);
```

## 031 Пространства имен

_Пространство имен_ - это декларативная область, в рамках которой определяются различные идентификаторы (имена типов, функций, переменных, ...).

Используются для видимого разграничения различных идентификаторов, а также для разрешения возможных конфликтов имен.

Пример объявления пространства имен:
```c++
namespace type {
    inline bool is_digit(char c);
    inline bool is_alpha(char c);
}
```

## 032 Определение пространства имен

_Определение пространства имен продемонстрировано в примере к пункту 31_.

## 033 Ключевое слово using как директива

_Using-директивы_ используются для подключения идентифаторов пространства имен в общее пространство имен.

Пример: 
```c++
using namespace std;
```

## 034 Ключевое слово using как объявление

_Using-объявление_ используется для для включения идентификатора из пространства имен в общую область видимости.

Пример:
```c++
using std::cin;
```

## 035 Псевдоним пространства имен

Пространствам имен можно давать псевдонимы:
```c++
namespace preudo = name;
```
_Примечание._ Ключевое слово `using` можно использовать для задания имен-синонимов (псевдонимов):
```c++
using integer = unsigned int;
```

## 036 Наследование

_Наследование_ - концепция объектно-ориентированного программирования, согласно которой абстрактный тип данных может наследовать данные и функциональность некоторого существующего типа, способствуя повторному использованию компонентов программного обеспечения. 

В языке C++ существует три вида наследования `public`, `private` и `protected`.

В зависимости от типа наследования, методы и поля базового класса получают определенные спецификаторы доступа в производном классе.

Ниже представлена таблица преобразования спецификаторов доступа в зависимости от типа наследования.

| Тип наследования | public    | private  | protected | 
|:-----------------|:----------|:---------|:----------|
| public           | public    | private  | protected |   
| private          | private   | private  | private   |   
| protected        | protected | private  | protected |

В языке C++ реализован принцип множественного наследования:
производный класс может быть унаследован от нескольких базовых классов.

## 037 Наследование (производные классы)

_Производным_ называется класс, унаследованный от другого класса, и, как правило, расширенный собственными данными и поведением.

Пример:
```c++
class Figure {
public:
    Figure(double x, double y);

    double center_x() const;
    double center_y() const;

private:
    double m_x, m_y;
}

class Circle : public Figure {
public:
    Circle(double x, double y, double r) : Figure(x, y);

    // методы center_x() и center_y() унаследованы

    double radius() const;
    double square() const;
    double length() const;

private:
    double m_r;
}
```

## 038 Конструкторы и деструкторы при наследовании

Механизм вызовы конструкторов и деструкторов при наследовании работает следующим образом:
1. конструкторы вызываются от базового класса к производному;
2. деструкторы вызываются от производного класса к базовому.

Данный принцип позволяет соблюдать очередность инициализации и удаления данных, тем самым обеспечивая корректную работу логики конструкторов и деструкторов при создании и удалении объектов.

## 039 Виртуальные функции

_Виртуальными_ называются функции, чье поведение определено не на уровне компиляции, а на уровне _времени выполнения программы_.

В языке C++ данный механизм основывается на VMT (virtual method table - таблица виртуальных методов).

Если в классе определены функции с модификатором `virtual`, то объект этого класса содержит поля, каждое из которых хранит указатель на соответствующий метод в _таблице виртуальных методов_.

Случай, когда функция `virtual` не реализует поведения по умолчанию, называется объявлением _чисто виртуальной функции_.

Пример объявления класса с чисто виртуальной функцией:
```c++
class Figure {
public:
    Figure(double x, double y);

    double x() const;
    double y() const;
    virtual double square() const = 0;

private:
    double m_x, m_y;
}
```

_Примечание._ Невозможно создать экземпляр класса, содержащего чисто виртуальную функцию.

## 040 Абстрактные классы

_Абстрактным_ называется такой класс, который содержит хотя бы одну _чисто виртуальную функцию_.

Как уже и было сказанно в _пункте 39_, невозможно создать экземпляр абстрактного класса.

Абстрактный класс лишь определяет таблицу виртуальных методов, которая будет заполняться его потомками.

Абстрактный класс можно использовать как тип, обобщающий все производные от него классы.

Пример:
```c++
class Rectangle : public Figure {
public:
    Square(double x, double y, double a, double b);

    double a() const;
    double b() const;
    double square() const override;
};

class Circle : public Figure {
public:
    Circle(double x, double y, double r);

    double r() const;
    double square() const override;
}
```

## 041 Виртуальные деструкторы

В языке C++ деструктор _полиморфного_ базового класса должен объявляться _виртуальным_.

Такое требование обеспечивает правильное разрушение объекта производного класса через указатель на таблицу виртуальных методов (деструктора).

Пример:
```c++
class Storage {
public:
    Storage(unsigned int size) : m_size(size){}
    virtual ~Storage() = 0;

private:
    unsigned int m_size;
}

class Array : public Storage {
public:
    Array(unsigned int size, const int* e) 
         : Storage(size)
    {
        m_storage = new int[size];
        
        for(int i = 0; i < size; i++){
            m_storage = e[i];
        }
    }

    ~Array(){
        delete m_storage;
    }

private:
    int* m_storage;
}

class Mapping : public Storage {
public:
    Mapping(unsigned int size, const int* a, const int* b) 
           : Mapping(size)
    {
        m_keys = new int[size];
        m_values = new int[size];

        for(int i = 0; i < size; i++){
            m_keys = a[i];
            m_values = b[i];
        }
    }

    ~Mapping(){
        delete m_keys;
        delete m_values;
    }

private:
    int* m_keys, m_values;
}
```

_Примечание._ _Полиморфным_ называется класс, использующий модификатор `virtual`.

## 042 Динамическое и статическое связывание

В контексте компилируемых языков _связывание_ - это связь между вызовом функции и определением функции. 

Когда функция вызывается в C++, управление программой привязывается к адресу памяти, где эта функция определена.

В языке C++ существует два вида привязки (связывания):
1. статическое (раннее);
2. динамическое (позднее).

Ниже перечислены ключевые особенности динамического и статического связывания:

1. Статическая привязка происходит во время компиляции, а динамическая привязка — во время выполнения.

2. При статической привязке определение функции и вызов функции связываются во время компиляции, тогда как при динамической привязке вызовы функций не разрешаются до времени выполнения. 

3. Статическая привязка происходит, когда вся информация, необходимая для вызова функции, доступна во время компиляции. Динамическое связывание происходит, когда компилятор не может определить всю информацию, необходимую для вызова функции, во время компиляции.

4. Статическая привязка может быть достигнута с помощью обычных вызовов функций, перегрузки функций и перегрузки операторов, тогда как динамическая привязка может быть достигнута с использованием виртуальных функций.

5. Статическая привязка приводит к более быстрому выполнению программы. В отличие от статического связывания вызов функции не разрешается до времени выполнения для последующего связывания, что приводит к несколько более медленному выполнению кода.

6. Основным преимуществом динамического связывания является его гибкость, поскольку одна функция может обрабатывать различные типы объектов во время выполнения. Это значительно уменьшает размер кодовой базы, а также делает исходный код более читабельным.

Пример статического связывания:
```c++
class Computer
{
public:
    static int sum(int x, int y){
        return x + y;
    }

    static int sum(int x, int y, int z){
        return x + y + z;
    }
};

int main(){
    int sum2 = Computer.sum(1, 2);
    int sum3 = Computer.sum(1, 2, 3);
}
```

Пример динамического связывания:
```c++
class Base {
public:
    virtual void process(){
        cout << "The base class function is called.\n";
    }
};
 
class Derived: public Base {
public:
    void process() override {
        cout << "The derived class function is called.\n";
    }
};
 
int main()
{
    Base base;
    Derived derived;
 
    Base* base_ptr = &base;
    base_ptr->process();
 
    base_ptr = &derived;
    base_ptr->process();
 
    return 0;
}
```

Результат выполнения программы:
```
The base class function is called.
The derived class function is called.
```

Как видно выше, несмотря на вызов метода `process()` для указателя на объект типа `Base`, во втором случае сработало поведение класса `Derived`, так как перед вызовом метода произошло динамическое связывание по указателю.

## 043 Множественное наследование

Как было упомянуто в _пункте 36_, в языке C++ реализован  механизм множественного наследования.

Суть данного механизма заключается в том, что производный класс может быть унаследован более чем от одного базового класса.

Пример:
```c++
class Functional {
public:
    virtual void execute() = 0;
} 

class Temporary {
public:
    virtual void remove() = 0;
}

class Lambda : public Functional, public Temporary {
public:
    void execute() override;
    void remove() override;
}
```

Множественное наследование обладает рядом видимых преимуществ, таких как наследование поведения от нескольких классов,
однако порождает некоторые проблемы.

Примером такой проблемы является _ромбовидное наследование_: при данном виде множественного наследования производный класс образуется от базовых, которые в свою очередь связаны отношением наследования с общим родителем.

Пример ромбовидного наследования:
```c++
class Serializable {
public:
    virtual std::string to_string() = 0;
};

class Man : public Serializable {
public:
    std::string to_string() override {
        return "man";
    }
};

class Profession : public Serializable {
public:
    std::string to_string() override {
        return "profession";
    }
};

class Worker : public Man, public Profession {
public:
    std::string to_string() override {
        return "worker";
    }
};

int main(){
    Worker worker;
    std::cout << worker.to_string() << std::endl
              << worker.Man::to_string() << std::endl
              << worker.Profession::to_string() << std::endl;
}
```

Результат выполнения программы:
```
worker
man
profession
```

В результате экземпляр класса `Worker` содержит для экземпляра класса `Serializable`: один экземпляр от `Man` и один экземпляр от `Profession`.

Таким образом, экземпляры данных классов имеют следующие размеры:
- `sizeof(Man) = 8 bytes`,
- `sizeof(Profession) = 8 bytes`,
- `sizeof(Worker) = 16 bytes`.

Проблема ромбовидного наследования может быть решена несколькими способами, в том числе и при помощи _виртуального наследование_,
которое описано в _пункте 44_.

## 044 Виртуальное наследование

По умолчанию наследование в C++ является специальной формой композиции по значению.

Когда мы пишем:
```c++
class Derived : public Base {};
```
каждый объект класса `Derived` содержит в себе все нестатические данные-члены подобъекта своего базового класса `Base`, а также нестатические члены, объявленные в самом классе `Derived`.

В случае одиночного наследования эта форма композиции по значению, поддерживаемая механизмом наследования, обеспечивает компактное и эффективное представление объекта.

Проблема возникает тогда, когда некоторый базовый класс неоднократно встречается в иерархии наследования объекта.

Рассмотрим следующий пример _проблемы множественного наследования_:
```c++
#include <iostream>

class Entity {
public:
    Entity(){
        m_health = 1.0;
        std::cout << "Entity constructor" << std::endl;
    }

private:
    double m_health;
};

class Magician : public Entity {
public:
    Magician(){
        std::cout << "Magician constructor" << std::endl;
    }
};

class Warrior : public Entity {
public:
    Warrior(){
        std::cout << "Warrior constructor" << std::endl;
    }
};

class Wizard : public Magician, public Warrior {
public:
    Wizard(){
        std::cout << "Wizard constructor" << std::endl;
    }
};

int main(){
    Wizard wizard;
}
```

Результат выполнения программы:
```
Entity constructor
Magician constructor
Entity constructor
Warrior constructor
Wizard constructor
```

При такой реализации каждый объект класса `Wizard` содержит в себе два подобъекта `Entity` - `Magician::Entity` и `Warrior::Entity`.

Такая ситуация порождает несколько проблем:
- во-первых, данная реализация приводит к неэффективному использованию памяти и ресурсов программы, так как каждый экземпляр `Wizard` содержит в себе два экземпляра `Entity`, хотя самому `Wizard` достаточно лишь одного `Entity`, а другой является избыточным;
- во вторых, подобная ситуация приводит к некоторой неопределенности: при использовании методов и полей `Entity`, компилятор не знает, по какой ветви наследования идет обращение.

Решением данной проблемы является _виртуальное наследование_:
```c++
#include <iostream>

class Entity {
public:
    Entity(){
        m_health = 1.0;
        std::cout << "Entity constructor" << std::endl;
    }

private:
    double m_health;
};

class Magician : public virtual Entity {
public:
    Magician(){
        std::cout << "Magician constructor" << std::endl;
    }
};

class Warrior : public virtual Entity {
public:
    Warrior(){
        std::cout << "Warrior constructor" << std::endl;
    }
};

class Wizard : public Magician, public Warrior {
public:
    Wizard(){
        std::cout << "Wizard constructor" << std::endl;
    }
};

int main(){
    Wizard wizard;
}
```

Результат выполнения программы:
```
Entity constructor
Magician constructor
Warrior constructor
Wizard constructor
```

В этом случае изменяется принцип представления экземпляров классов:
- `Magician` и `Warrior` хранят собственные поля (в данном случае - ничего) и `virtual base pointer` - указатель, связывающий объект с подобъектом от базового класса `Entity`;
- `Wizard` последовательно включает в себя поля подобъектов от классов `Magician` и `Warrior` (в данном случае - указатели), а также поля подобъекта от базового класса `Entity`, на который те указатели указывают.

Таким образом, механизм _виртуального наследования_ позволяет избавиться от дублирования экземпляра базового класса.
 
## 045 Перегрузка функций

В широком смысле _перегрузка_ - это возможность одновременно использовать несколько функций с одним именем.

Функции называются перегруженными, если они объявлены в одной области видимости и имеют одно и то же имя.

Перегруженные функции не могут иметь разные типы возвращаемого значения, спецификатор исключений (`noexcept`) или спецификатор удаленной функции (`=delete`) при одинаковых параметрах.

Ниже представлен пример перегрузки функции в одной области видимости:
```c++
namespace current 
{
    int function(int);
    int function(int, unsigned short);
}
```

Перегрузка функций также возможна при составлении иерархии наследования:
```c++
class Base {
public:
    void process(int);
}

class Derived : public Base {
public:
    void process(double);
}

int main(){
    Derived x;
    x.process(42);
}
```

_Примечание._ Значение `42` является значением типа `int`, однако в результате работы программы будет вызван метод `Derived::process(double)`.
Данный факт связан с принципом _доминирования_ при наследовании, согласно которому в первую очередь рассматриваются имена, определенные в данной области видимости.

## 046 Перегрузка операторов

_Перегрузка операторов_ схожа с перегрузкой функций и существует для определения поведения _операторов_ для пользовательских типов.

Правила перегрузки операторов:
- Язык C++ не допускает определения для операций нового лексического символа, кроме уже определенных в языке.
- Не допускается перегрузка операций для встроенных типов данных.
- Нельзя переопределить приоритет операции.
- Нельзя изменить синтаксис операции в выражении. 
- Перегружать можно только операции, для которых хотя бы один аргумент представляет тип данных, определенный пользователем.
- Функция-операция должна быть определена либо как функция-член класса, либо как внешняя функция, но дружественная классу.

Ниже представлен пример перегрузки оператора:
```c++
class Matrix {
    ...
    friend Matrix operator(cons Matrix& a, const Matrix& b);
};

Matrix operator+(const Matrix& a, const Matrix& b){...}
```

В данном примере реализована перегрузка бинарного оператора `operator+()` как дружественной функции класса `Matrix`.

## 047 Перегрузка бинарного оператора

Если бинарная операция перегружается с использованием метода класса, то в качестве своего первого аргумента она получает неявно переданную переменную класса (указатель `this` на объект), а в качестве второго - аргумент из списка параметров. 

То есть, фактически бинарная операция, перегружаемая методом класса, имеет один аргумент - правый операнд, а левый передается неявно через указатель `this`.

Ниже представлен пример перегрузки оператора как метода класса:
```c++
class Matrix {
    ...
    Matrix operator+(const Matrix& other);
};
```

Если бинарная операция перегружается дружественной функцией, то в списке параметров она должна иметь оба аргумента:
```c++
class Vector {
    ...
    friend Vector operator+(const Vector& a, const Vector& b);
    friend Vector operator*(const int a, const Vector& v);
};

Vector operator+(const Vector& a, const Vector& b){...}
Vector operator*(const int a, const Vector& v){...}
```

Данный способ можно использовать в тех случаях, когда левым операндом должно быть значение типа, отличного от данного.

## 048 Перегрузка унарного оператора

Как и _бинарные операторы_, _унарные_ могут быть перегружены двумя способами: как методы класса и как дружественные внешние функции.

Ниже представлен пример перегрузки унарных операторов:
```c++
class Number {
    ...
    Number operator+() const;
    friend Number operator-(const Number& number);
}
```

В данном примере оператор `operator+()` перегружен как метод класса, в то время как оператор `operator-()` перегружен как дружественная функция класса.

Особое внимание привлекает перегрузка операторов инкремента и декремента, а именно то, как происходит перегрузка префиксной и постфиксной форм.

Префиксная форма перегружается в виде `T& operator++()`, в то время как перегрузка постфиксной формы осуществляется за счет добавления фиктивного параметра int: `T operator++(int)`.

## 049 Дружественная функция operator

Как уже было сказано в _пунктах 46, 47, 48_, одним из способов перегрузки операторов является перегрузка операторов через их объявления как функции, дружественной классу.

Данный способ перегрузки операторов позволяет использовать в качестве левого операнда бинарных операторов типы, отличные от типа класса, в том числе и стандартные типы языка С++.

Спецификатор _friend_ в данном случае используется для того, чтобы получить доступ к полям операнда-класса наравне с реализацией перегрузки оператора через объявление того методом класса.

## 050 Особенности перегрузки операции =

Перегрузка оператора `operator=()` имеет следующие особенности:
- оператор присваивания может быть перегружен как оператор присваивания копирования, который по умолчанию определяется в рамках _правила трёх_ как копирование полей одного экземпляра в другой;
- оператор присваивания может быть перегружен как оператор  присваивания перемещения, который по умолчанию определяется в рамках _правила пяти_ как обмен полями одного экземпляра с другим;
- при использовании операции `=` для инициализации объекта через копирование (`T t = T(lvalue)`) вызывается конструктор копирования, а не оператор присваивания копирования;
- при использовании операции `=` для инициализации объекта через перемещение (`T t = T(rvalue)`) вызывается конструктор перемещения, а не оператор присваивания перемещения;
- многие анализаторы кода рекомендуют производить сравнение операнда оператора и текущего объекта, так как в случае последовательного присваиванием возможна ситуация присваивания данных самому себе.

## 051 Перегрузка оператора []

Перегрузка оператора `[]` чаще всего используется для определения поведения взятия элемента по некоторому ключу/индексу у абстрактного типа данных, представляющего собой последовательную или ассоциативную коллекцию.

Пример:
```c++
#include <iostream>
#include <vector>
#include <map>

using namespace std;

int main(){
    vector<int> numbers = {1, 2, 3, 4, 5};
    map<string, int> tarot = {{"Chariot", 7}, {"Death", 13}};

    cout << boolalpha
         << (numbers[0] == numbers.operator[](0)) << endl
         << (tarot["Death"] == tarot.operator[]("Death")) << endl;
}
```

Результат выполнения программы:
```
true
true
```

В данном примере продемонстрированы контейнеры стандартной библиотеки STL, содержащие перегрузку оператора `operator[]`.

_Примечание._ До стандарта языка C++23 оператор `operator[]` не мог иметь более одного `subscript`, т.е., не представлялось возможности перегрузить операцию индексации коллекций размерностью более одного. Решением данной проблемы стало использование в качестве оператора индексации `operator()` с двумя и более индексами `subscript`.

## 052 Перегрузка оператора ()

Перегрузка оператора `()` чаще всего используется для определения функционального поведения объектов классов.

Пример:
```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(){
    struct {
        bool operator()(const int& a, const int& b){
            return a < b;
        }
    }
    comparator;

    vector<int> numbers = {3, 2, 1, 5, 6};
    sort(numbers.begin(), numbers.end(), comparator);

    for(auto i : numbers){
        std::cout << i << ' ';
    }
    std::cout << std::endl;
}
```

Результат выполнения программы:
```
1 2 3 5 6
```

В примере выше объявлен экземпляр анонимной структуры, выполняющей задачи функционала-компаратора для сортировки некоторого массива целых чисел.

_Примечание._ Как было сказано в _пункте 51_, оператор `operator()` используется для многомерной индексации, например, `matrix` в библиотеке `boost`.

## 053 Преобразование типов

_Преобразование типов_ - это механизм языка C++, позволяющий приводить и присваивать значения одного типа к другому.

Преобразования типов бывают _явные_ и _неявные_.

Неявное преобразование типа (также называемое автоматическим преобразованием типа или принуждением) выполняется компилятором автоматически, когда требуется один тип данных, но предоставляется другой тип. Подавляющее большинство преобразований типов в C++ являются неявными преобразованиями типов. Например, неявное преобразование типа происходит во всех следующих случаях:
```c++
// неявное преобразование int в double
double a {6};
double b = 3;

// неявное преобразование int в bool
if(10){...}

// неявное преобразование double в int (сужение типа)
int x = 10.5;
```

Как видно из примеров выше, неявное преобразование действует во всех случаях, в которых компилятор может найти приемлемое преобразование. Тем не менее, компиляция представленного ниже кода завершится с ошибкой:
```c++
int x {10.5}; 
```

```
type 'double' cannot be narrowed to 'int' in initializer list
```

Стандартные преобразования можно условно разделить на 4 категории, каждая из которых охватывает различные типы преобразований:
- числовые продвижения;
- числовые преобразования;
- арифметические преобразования;
- другие преобразования.

## 054 Явные преобразования типов

_Явное приведение типа_ - это специальная конструкция языка программирования, которая указывает, как трактовать тип определенной переменной (или результат выражения).
Приведение типов игнорирует любую дополнительную информацию и никогда ее не добавляет.

Существуют следующие операторы явного преобразования типов данных:
- конвертация в стиле языка Си;
- применение оператора `static_cast`;
- применение оператора `const_cast`;
- применение оператора `dynamic_cast`;
- применение оператора `reinterpret_cast`.

### Применение легаси-конвертации

В программировании кода в легаси-стиле (стиль разработки на языке Си) используется оператор приведения типов `()`:
```c++
double x = 10.5;
int y = (int) x;
```

Данное приведение является опасным, так как не содержит никаких проверок на соответствие типов и модификаторов доступа, а просто отбрасывает все несоответствия и ограничивается стандартными преобразованиями простых типов.

### Применение оператора static_cast

Оператор `static_cast` используется для приведения типов, которое может быть выполнено только на этапе компиляции.

Возвращает ошибку, если компилятор обнаруживает, что имеет место попытка выполнить приведение между полностью несовместимыми типами. Его также можно использовать для приведения между указателем на базовый и на производный класс, но компилятор не всегда может определить, будет ли такое преобразования безопасными во время выполнения.

Ниже представлен пример использования оператора `static_cast`:
```c++
int main(){
    double d = 3.14;
    int i = static_cast<int>(d);
    string s = static_cast<string>(d); // error
}
```

В примере выше линия кода с приведением типа `double` к типу `string` вызовет ошибку, так как такое приведение не было определено на этапе компиляции.

### Применение оператора dynamic_cast

Оператор `dynamic_cast` используется для безопасного приведения полиморфных типов во время выполнения программы.

В связи с тем, что проверка выполняется не на этапе компиляции, а на этапе времени выполнения, вызов оператора может сопровождаться некоторыми задержками.

Ниже представлен пример использования оператора `dynamic_cast`:
```c++
int main(){
    Base* base = new Derived;
    Derived* derived = dynamic_cast<Derived*>(base);
}
```

В примере выше выполняется _downcast_ указателя на экземпляр базового класса к указателю на экземпляр производного класса.

Попытка неверного приведения указателя с помощью `dynamic_cast` приведет к возвращению значения `nullptr`:
```c++
Base* base = new Derived;
Zero* zero = dynamic_cast<Zero*>(base); // nullptr
```

Попытка неверного приведения ссылки с помощью `dynamic_cast` приведет к выбрасыванию исключения `bad_cast`:
```c++
Base* base = new Base;
Error& error = dynamic_cast<Error&>(*base); // error
```

### Применение оператора const_cast

Оператор `const_cast` используется для изменения модификаторов `const` и `volatile`.

Ниже представлен пример использования оператора `const_cast`:
```c++
int main(){
    int x = 10;
    const int& y = const_cast<const int&>(x);
    int& z = const_cast<int&>(y);
    z = 20;
}
```

Чаще всего `const_cast` используется для того, чтобы опустить модификатор памяти `const` и обеспечить модификацию значения по указателю или ссылке, однако возможно и обратное приведение.

### Применение оператора reinterpret_cast

Оператор `reinterpret_cast` используется для приведения между несвязанными типами, такими как тип указателя и `int`.

Отличие от небезопасного _C-cast_ состоит в том, что `reinterpret_cast` не может снимать квалификаторы `const` и `volatile`, а также не может делать небезопасные преобразования типов не через указатели, а напрямую через значения.

Ниже представлен пример использования оператора `reinterpret_cast`:
```c++
int main(){
    char* pc = new char[100];
    void* pv = reinterpret_cast<void*>(pc);
    long* pl = reinterpret_cast<long*>(pv);
}
```

В примере выше все приведения производятся над указателем на массив, который в дальнейшем будут восприниматься (_интерпретироваться_) как указатель на массив другого типа.

## 055 Преобразования типов, определенных в программе

Язык C++ позволяет определять собственные _преобразования_ типов.

Ниже представлен пример программы, использующей перегрузку оператора приведения типа:
```c++
#include <iostream>

class Number {
public:
    Number(int v) : m_v(v){}
    operator int() const {return m_v;}

private:
    int m_v;
};

int main(){
    Number x = 10;
    int y = x;
    std::cout << x << ' ' << y << std::endl;
}
```

Результат выполнения программы:
```
10 10
```

_Примечание._ Многие компиляторы и статические анализаторы кода рекомендуют определять конструкторы и операторы приведения типов как `exlicit` во избежание неявных преобразований, работа которых продемонстрирована в примере выше. 

## 056 Параметризированные классы

В языке C++ предусмотрена реализация еще одного типа _полиморфизма_, отличного от полиморфизма функций, упомянутого в _пункте 45_, - это механизм параметризованных классов и параметризованных функций.

_Параметризованный класс_ - это некий шаблон (`template`), на основе которого можно строить другие классы.

Описание шаблона имеет вид:
```c++
template<param1, param2, ..., paramN>
```
где _param1, param2, ..., paramN_ - некоторые _шаблонные параметры_.

В списке параметров могут присутствовать как параметры, определяющие тип, так и параметры, для которых этот тип фиксирован:
```c++
template<typename T, size_t N>
class Array {
    ...
}
```

В примере выше определен шаблонный класс с _параметром типа T_ и параметром _size_t N_.

Параметры, определяющие тип, задаются при помощи ключевых слов `typename` и `class`.

_Примечание._ Система параметрических шаблонов является одной из самой противоречивых в языке C++. 
Она претерпела многие изменения с момента своего появления в стандарте C++98 до введения _constraits and concepts_ в C++20.

## 057 Передача в шаблон класса дополнительных параметров

Как уже было сказано в _пункте 57_, при создании экземпляра класса в него могут быть переданы не только типы, но и переменные и константные выражения:
```c++
template<typename T, int counter = 0>
class Statistics {
...
T m_param;
int m_counter = counter;
}
```

_Примечание._ Данные параметры не являются дополнительными в полной мере, поскольку могут определять свойства классов, задаваемых данным шаблоном.

## 058 Шаблоны функций

В С++, так же как и для класса, для глобальной функции может быть описан шаблон. Это позволит снять достаточно жесткие ограничения, накладываемые механизмом формальных и фактических параметров при вызове функции.

Рассмотрим это на примере функции, вычисляющей сумму нескольких аргументов:
```c++
#include <iostream>

template<typename... Types>
auto sum(Types... args){
    return (args + ...);
}

int main(){
    std::cout << sum(1, 2, 3, 4, 5) << ' '
              << sum(1, 2, 3, 4) << ' '
              << sum(1, 2, 3) << ' '
              << sum(1, 2) << ' '
              << sum(1) << std::endl;
}
```

Результат выполнения программы:
```
15 10 6 3 1
```

В данном примере шаблон функции порождает _пять_ функций с разным числом целочисленных параметров, каждая из которых выполняет сложение передаваемых в нее аргументов.

_Примечание._ В примере выше используется `variadic template` для определения последовательности раскручиваемых значений, а для разложения бинарной операции сложения по отношению к ним - `fold expression`, появившийся в стандарте C++17.

## 059 Совместное использование шаблонов и наследования

Шаблонные классы, как и обычные, могут использоваться повторно. 
Шаблоны и наследование представляют собой механизмы повторного использования кода и могут включать полиморфизм. 

Шаблоны и наследование связаны между собой следующим образом:
- шаблон класса может быть порожден от обычного класса;
- шаблонный класс может быть производным от шаблонного класса;
- обычный класс может быть производным от шаблона класса.

Ниже представлен пример всех возможных ситуаций при наследовании с шаблонами:
```c++
class Abstract {};

template<typename T>
class Base : public Abstract {};

template<typename T>
class Derived1 : public Base<T> {};

class Derived2 : public Base<int> {};
```

_Примечание._ Определение класса _Derived2_ является простейшим примером _частичной специализации шаблонов_ (ситуации, когда одно объявление имени делает делает шаблон другого объявления этого имени более узким по контексту).

## 060 Организация ввода/вывода

Как правило, ввод-вывод выполняется с помощью средств стандартной библиотеки:
- В С для этих целей используется библиотека `<stdio.h>`;
- В С++ разработана новая библиотека ввода-вывода `<iostream>`, использующая концепцию объектно-ориентированного программирования.

Механизм, на котором в стандартной библиотеке языка C++ реализован ввод/вывод, называется _потоками данных_.

На абстрактном уровне _поток данных_ - это последовательность простейших единиц информации, к которой можно получить доступ.

Библиотека `<iostream>` определяет три глобальных объекта-потока ввода/вывода:
- `std::cin` - стандартный поток ввода (аналог `stdin`);
- `std::cout` - стандартный поток вывода (аналог `stdout`);
- `std::cerr` - стандартный поток ошибок (аналог `stderr`).

_Примечание._ По умолчанию в консольном режиме программы данные потоки направлены на ввод с клавиатуры и на вывод на экран, но могут быть переопределены.

Для выполнения операций ввода-вывода переопределены две операции поразрядного сдвига:
- `>>` - получить данные из входного потока;
- `<<` - поместить данные в выходной поток.

_Примечание._ Данный вопрос уже поднимался в _пунктах 10-13_, однако включал в себе вопросы, связанные с вводом/выводом на экран.

Для ввода/вывода данных для файлов и прочих дескрипторов файловой системы используются средства библиотеки `<fstream>`.

Основными классами для работы с файлами являются `std::ifstream` и `std::ofstream`, унаследованные от `std::istream` и `std::ostream` соответственно.

Работа с потоками файлового ввода/вывода осуществляется следующим образом:
- при помощи конструктора либо функции `open` файл открывается с определенными пользователем либо по умолчанию флагами открытия;
- при помощи функций взаимодействия с потоками происходит ввод/вывод;
- поток закрывается при помощи функции `close`.

## 061 <Данный вопрос отсутствует>

...

## 062 Перегрузка операторов ввода и вывода

Ранее в _пункте 46_ уже обсуждалась перегрузка бинарных операторов.

Операторы ввода и вывода, являясь бинарными операторами, тоже могут быть перегружены:
```c++
std::istream& operator>>(std::istream& istream, const T& istream){...}
std::ostream& operator<<(std::ostream& ostream, const T& object){...}
```

_Примечание._ Операторы ввода и вывода возвращают ссылку на передаваемый им в качестве первого операнда аргумент. Это сделано для того, чтобы обеспечить последовательный ввод и вывод нескольких значений.

## 063 Функция get() с тремя параметрами

Функция `get` определена в `std::basic_istream` и служит для получения текущего набора значений из потока.

Вариант функции `get` с тремя аргументами определен как:
```c++
basic_istream& get(char_type* s, std::streamsize count, char_type delim);
```

Читает символы и записывает их по указанному адресу, при этом символы считываются и записываются до тех пор, пока не произойдет следующее:
- `count - 1` символ был считан;
- будет достигнут конец файла (будет установлено состояние `eofbit`);
- следующий доступный для чтения символ является `delim` (не будет прочитан);

Если ни один символ не был прочитан, устанавливается состояние `failbit`.

При любом исходе текущий символ массива данных по адресу `s` будет записан как _нулевой_.

## 064 Функция get() без параметров и с одним параметром

В _пункте 63_ описано назначение функции `get`, определенной в `std::basic_istream`.

Вариант функции `get` без параметров определен как:
```c++
int_type get();
```

В результате выполнения будет возвращен код символа, который был прочитан, либо `eof` (в этом случае будет установлено состояние `failbit` и `eofbit`).

Вариант функции `get` с одним параметром определен как:
```c++
basic_istream& get(char_type& ch);
```

В результате его выполнения в переменную `ch` будет записан прочитанный символ, в противном случае `ch` не будет изменен (будет установлено состояние `failbit` и `eofbit`).

## 065 Функция getline()

Функция `getline` определена в `std::basic_istream` и служит для получения последовательности символов, образующих _строку_.

Функция определена следующим образом:
```c++
basic_istream& getline(char_type* s, std::streamsize count);
basic_istream& getline(char_type* s, std::streamsize count, char_type delim);
```

Считывает символы и записывает их по адресу `s` до тех пор, пока не произойдет следующее:
- достигнут конец файла (будет установлено состояние `eofbit`);
- следующий доступный символ равен `delim` (в отличие от `get` этот символ будет считан, однако не будет записан);
- `count - 1` символ был считан.

Если функция не прочитала ни одного символа, будет установлено состояние `failbit`.

Количество прочитанных символов можно узнать при помощи функции `gcount`.

## 066 Состояние потока

При взаимодействии с потоками может изменяться их состояние (например, при возникновении ошибок чтения).

Для определения состояния потока существуют следующие флаги состояния:
- `ios_base::badbit`;
- `ios_base::eofbit`;
- `ios_base::failbit`;
- `ios_base::goodbit`.

## 067 Функции чтения состояния потока

Для выявления текущего состояния потока используются следующие функции:
- `good` - возвращает `goodbit`;
- `eof` - возвращает `eofbit`;
- `fail` - возвращает `failbit`;
- `bad` - возвращает `badbit`;
- `rdstate` - возвращает `iostate` (состояние потока);
- `setstate` - устанавливает `iostate`;
- `clear` - очищает флаги ошибок и конца файла.

## 068 Организация работы с бинарными файлами. Запись объектов в файл и чтение объектов из файла

Для организации работы с бинарными файлами необходимо открыть файл с режимом открытия `std::ios::binary`.

Ниже представлен пример записи объектов в бинарный файл:
```c++
#include <fstream>

int main(){
    std::ofstream output("output.bin", std::ios::binary | std::ios::out);
    output << (int) 1 << (double) 12.5 << std::endl;
    output.close();
}
```

Ниже представлен пример чтения объектов из бинарного файла:
```c++
#include <fstream>

int main(){
    std::ifstream input("input.bin", std::ios::in);
    int i;
    double d;
    input << i << d;
    input.close();
}
```

## 069 Организация работы с файлами последовательного доступа. Запись объектов в файл и чтение объектов из файла

_Файлы последовательного доступа_ - это файлы, хранящие информацию в неструктурированном для поиска и обращения виде.

Поиск в таких файлах осуществляется последовательным считыванием файла с начала и сравнением «всего» с искомым, при этом обращение к определенному участку файла каждый раз требует «чтения с начала».

Примером _файла последовательного доступа_ является текстовый файл, хранящий в себе некоторый символический текст, поиск определенного слова в котором требует анализа всего содержимого с самого начала файла.

## 070 Организация работы с файлами произвольного доступа. Запись объектов в файл, чтение объектов из файла, перезапись объектов в файле

_Файлы произвольного доступа_ - это файлы, хранящие информацию в структурированном для поиска и обращения виде. 

Поиск в таких файлах осуществляется в области адресов (ключей) и завершается обращением непосредственно к искомому участку.

Примером _файла произвольного доступа_ является бинарный файл, хранящий в себе слова фиксированной длины, поиск определенного слова по индексу (ключу) в котором осуществляется простым указанием по смещению поля слова относительно начала файла.

_Примечание._ О том, как осуществляется указание определенную позицию в файле, рассказывается в _пункте 71_.

## 071 Функции позиционирования в файле

Для указания на определенную позицию в файле существуют специальные _функции позиционирования_, позволяющие не только узнать текущую позицию _указателей на чтение и запись_, но также и изменить их положение.

Данные функции определены как:
```c++
pos_type tellp();
pos_type tellg();

basic_ostream& seekp(pos_type pos);
basic_ostream& seekp(pos_type off, std::ios_base::seekdir dir);

basic_istream& seekg(pos_type pos);
basic_istream& seekg(pos_type off, std::ios_base::seekdir dir);
```
где
- `tellp` возвращает текущую позицию указателя на запись;
- `tellg` возвращает текущую позицию указателя на чтение;
- `seekp(pos_type)` устанавлявает смещение указателя на запись относительно начала;
- `seekp(pos_type, seekdir)` устанавливает смещение указателя на запись относительно направления;
- `seekg(pos_type)` устанавливает смещение указателя на чтение относительно начала;
- `seekg(pos_type, seekdir)` устанавливает смещение указателя на чтение относительно направления.

Существуют следующие константы направления, относительно которых устанавливается смещение:
- `beg` определяет смещение относительно начала файла;
- `cur` определяет смещение относительно текущей позиции;
- `end` определяет смещение относительно конца файла.

Ниже представлен пример программы, использующей позиционирование в файле:
```c++
#include <iostream>
#include <string>
#include <sstream>
 
int main()
{
    std::istringstream in("Hello, World!");
    std::string word1, word2, word3, word4, word5;
 
    in >> word1;
    in.seekg(+0, std::ios_base::beg);
    in >> word2;
    in.seekg(+1, std::ios_base::cur); 
    in >> word3;
    in.seekg(-6, std::ios_base::cur);
    in >> word4;
    in.seekg(-6, std::ios_base::end);
    in >> word5;
 
    std::cout << "word1 = " << word1 << '\n'
              << "word2 = " << word2 << '\n'
              << "word3 = " << word3 << '\n'
              << "word4 = " << word4 << '\n'
              << "word5 = " << word5 << '\n';
}
```

Результат выполнения программы:
```
word1 = Hello,
word2 = Hello,
word3 = World!
word4 = World!
word5 = World!
```

## 072 Абсолютный обработчик

Под _абсолютным обработчиком_ понимают блок `catch`, захватывающий и обрабатывающий все типы исключений.

Ниже представлен пример программы с абсолютным обработчиком:
```c++
#include <iostream>

int main(){
    try {
        throw 1;
    }
    catch(...){
        std::cout << "some error detected" << std::endl;
    }
}
```

Результат выполнения программы:
```
some error detected
```

## 073 Основы обработки исключительных ситуаций

Под _обработкой исключений_ понимается механизм, предназначенный для написания реакции программы на ошибки времени выполнения для сохранения работоспособного состояния программы, а также для их непосредственной обработки.

В языке C++ механизм обработки исключений реализован следующим образом:
1. блок кода, в котором ожидается возникновение ошибки, оборачивается в блок оператора `try`;
2. за блоком оператора `try` следуют блоки операторов `catch`, которые отвечают за обработку определенных исключений;
3. при возникновении ошибки в блоке оператора `try` она передается соответствующему обработчику `catch`;
4. если такой обработчик отсутствует, происходит развертывания стека и ошибка передается в следующий фрейм;
5. данная последовательность действий выполняется до тех пор, пока ошибка не будет обработана, либо пока ошибка не выйдет за пределы `main`, что приведет к вызову `terminate`.

## 074 Перенаправление исключительных ситуаций

Иногда возникает положение, при котором необходимо обработать исключительную ситуацию сначала на более низком уровне вложенности блока `try`, а затем передать ее на более высокий уровень для продолжения обработки. Для того чтобы сделать это, нужно использовать `throw` без аргументов. 

В этом случае исключительная ситуация будет перенаправлена к следующему подходящему обработчику:
```c++
#include <iostream>

void error_source(){
    throw 1;
}

void observer(){
    try {
        error_source();
    }
    catch(int e){
        std::cout << "Observer got " << e << " error" << std::endl;
        throw;
    }
}

int main(){
    try {
        observer();
    }
    catch(int e){
        std::cout << "Main got " << e << " error" << std::endl;
    }
}
```

Результат выполнения программы:
```
Observer got 1 error
Main got 1 error
```

_Примечание._ Оператор `throw` без аргументов перенаправляет активное исключение, однако если активного исключения не было, программа аварийно завершится со следующим сообщением:
```
terminate called without an active exception
```

## 075 Исключительная ситуация, генерируемая оператором new

Если для запроса на выделение недостаточно памяти, в `operator new` возникает исключение `std::bad_alloc` или возвращается `nullptr`, если была использована форма `new(std::nothrow)`.

В более некоторых версиях компиляторов возможно неопределённое поведение.

## 076 Генерация исключений в конструкторах

Если конструктор класса завершает работу исключением, значит он не завершает свою работу - следовательно объект не будет создан. Из-за этого могут возникать утечки памяти, т.к. для не полностью сконструированных объектов не будет вызван деструктор. Из-за этого распространено мнение, что конструктор никогда не должен вырабатывать исключения, однако это не так - _утечки памяти возникнут не во всех случаях_.

Стандарт языка С++ гарантирует, что если исключение возникнет в конструкторе, то память из под членов-данных класса будет освобождена корректно вызовом деструктора, т.е., если вы используете идиому _RAII (Resource Acquisition is Initialization - "получение ресурса есть инициализация")_, то проблем не будет.
Для этого достаточно использовать контейнеры STL вместо старых массивов и строк, и умные указатели вместо обычных.

## 077 Задание собственной функции завершения

Если не был найден ни один подходящий обработчик исключения, то вызывается стандартная функция `terminate()`, которая, в свою очередь, вызывает функцию `abort()` для завершения работы с приложением.

Для задания своей функции завершения её необходимо зарегистрировать с помощью функции `set_terminate()`, которая будет выполняться перед аварийным завершением работы.

Пример:
```c++
#include <iostream>

void MyTerminate(){
	std::cout << "An error occured!" << std::endl;
	exit(-1);
}

int main (){
	std::set_terminate(MyTerminate);
	throw 0;
}
```

Результат выполнения программы:
```
An error occured!

Process finished with exit code -1
```

## 078 Спецификации исключительных ситуаций

_Спецификации исключений_ — это функция языка C++, которая указывает на намерение программиста определить типы исключений, которые могут распространяться функцией. Также компилятор может использовать это для оптимизации.

Пример:

```c++
void foo1(int i) noexcept; // не вызывает исключений

void foo2(int i) throw(...) // может вызывать исключения любого типа

void foo3(int i) throw(type) // может вызвать исключение типа type
```

Также для данных спецификаторов существуют эквивалентные записи:
- `noexept` ~ `noexept(true)` ~ `throw()`;
- `throw(...)` ~ `noexept(false)`.

_Примечание._ Спецификация `throw(...)` была нерекомендуема начиная со стандарта С++11 и удалена в С++17.

## 079 Правила поиска обработчика исключительных ситуаций

При написании обработчиков исключительных ситуаций для блока `try` следует учитывать тот факт, что блоки `catch` проверяются _в порядке их следования_.

Таким образом, будет ошибкой размещать блоки `catch` следующим образом
```c++
try {
    ...
}
catch(const std::exception& e){
    ...
}
catch(const std::runtime_error& e){
    ...
}
catch(const std::overflow_error& e){
    ...
}
```
поскольку данные исключения расположены в следующей иерархии наследования
```c++
std::overflow_error <- std::runtime_error <- std::exception
```
и в таком случае все исключительные ситуации будут перехватываться обработчиком исключительных ситуаций базового класса исключений.

## 080 Механизм развертывания стека

_Развертывание стека_ – это процесс вызова деструкторов локальных объектов, когда происходит выход из их области видимости.

Вызов деструкторов осуществляется по правилу стека, т.е. деструктор последнего созданного объекта будет вызван первым.

Пример:

```c++
#include <limits.h>
#include <iostream.h>

class add_class { 
private:
    unsigned short num;

public:
    add_class(unsigned short a){ 
        num = a;
    	cout << "Constructor " << num << endl;
    }

    ~add_class(){ 
	cout << "Destructor " << num << endl; 
    }

    void show_num(){
	cout << " " << num << " "; 
    }

    void input_num(unsigned short a){ 
    	num = a; 
    }

    unsigned short output_num(){
    	return num;
    }
};

add_class add(add_class a,add_class b){ 
    add_class sum(0);
    unsigned long s = (unsigned long) a.output_num()+ 
                      (unsigned long) b.output_num();

    if(s > USHRT_MAX) throw (int) 1;

    sum.input_num((unsigned short) s);
    return sum;
}

void main(){ 
    add_class a(USHRT_MAX), b(1), s(0);

    try {
        s = add(a, b);
        cout << "Result";
        s.show_num();
        cout << endl;
    } 
    catch(int){
        cout << "Overflow error" << endl;
    }
}
```

Результат выполнения программы:
```
Constructor 65535
Constructor 1
Constructor 0
Constructor 0
Destructor 0
Destructor 65535
Destructor 1
Overflow error
Destructor 0
Destructor 1
Destructor 65535
```

## 081 Иерархия исключений стандартной библиотеки

Стандартная библиотека имеет следующую иерархию исключений:
- `logic_error` 

    - `invalid_argument`
    - `domain_error`
    - `length_error`
    - `out_of_range`
    - `future_error` (C++11) 

- `runtime_error` 

    - `range_error`
    - `overflow_error`
    - `underflow_error`
    - `regex_error` (C++11)
    - `system_error` (C++11) 

        - `ios_base::failure` (C++11)
        - `filesystem::filesystem_error` (C++17) 

    - `nonexistent_local_time` (C++20)
    - `ambiguous_local_time` (C++20)
    - `format_error` (C++20) 

- `bad_typeid`
- `bad_cast` 

    - `bad_any_cast` (C++17) 

- `bad_optional_access` (C++17)
- `bad_expected_access` (C++23)
- `bad_weak_ptr` (C++11)
- `bad_function_call` (C++11)
- `bad_alloc` 

    - `bad_array_new_length` (C++11) 

- `bad_exception`
- `ios_base::failure` (until C++11)
- `bad_variant_access` (C++17) 

## 082 Общее понятие о контейнере

В общем случае _контейнер_ - это способ хранения некоторой последовательности однотипных объектов в памяти программы.

В языке C++ существует два основных типа контейнеров:
- последовательные - поддерживают указанный пользователем порядок вставляемых элементов: `std::vector`, `std::array`, `std::list`, `std::forward_list` и др.;
- ассоциативные - поддерживают определенный порядок (упорядоченность) элементов и поддерживают быстрый поиск данных: `std::map`, `std::unordered_map`, `std::set`, `std::unordered_set`, `std::priority_queue` и др.

_Примечание_. В некоторых источниках виделяется еще один вид контейнеров - псевдоконтейнеры: `std::bitset`, `std::string`, `std::valarray`, которые представляют собой составные типы с определенными для них операциями.

## 083 Общее понятие об итераторе

_Итератор_ - это интерфейс, предоставляющий доступ к элементам коллекции (массива или контейнера) и навигацию по ним. 

В различных системах итераторы могут иметь разные общепринятые названия: 
- в терминах систем управления базами данных итераторы называются курсорами;
- в простейшем случае итератором в низкоуровневых языках является указатель. 

Использование итераторов в _обобщённом программировании_ позволяет реализовать универсальные _алгоритмы_ работы с _контейнерами_.

_Примечание_. Итераторы обычно используются парами, один из которых используется для указания текущей итерации, а второй служит для обозначения конца коллекции. Итераторы создаются при помощи соответствующих классов контейнеров, используя такие стандартные методы как `begin` и `end`: функция `begin` возвращает указатель на первый элемент, а `end` — на воображаемый несуществующий элемент, следующий за последним.

## 084 Категории итераторов

В зависимости от того, в какой последовательности расположены данные коллекции, а также от того, как предоставляется к этим данным доступ, итераторы подразделяются на некоторые _категории_.

Существующая классификация итераторов насчитывает пять категорий итераторов:
- Input iterator.
- Output iterator.
- Forward iterator.
- Bidirectional iterator.
- Random access iterator.
- Contiguous iterator (C++17).

_Примечание_: таблицу требований к категориям итераторов можно найти по 
[данной ссылке](https://en.cppreference.com/w/cpp/iterator).

## 085 Основные итераторы: итераторы ввода/вывода

Ответ на данный вопрос содержится по ссылке, указанной в примечании к _пункту 85_.

## 086 Вспомогательные итераторы

Ответ на данный вопрос содержится по ссылке, указанной в примечании к _пункту 85_.

## 087 Операции с итераторами

Ответ на данный вопрос содержится по ссылке, указанной в примечании к _пункту 85_.

## 088 <Данный вопрос отсутствует>

...

## 089 Контейнеры последовательностей

_Последовательный контейнер_ или _контейнер последовательностей_ - это контейнер, позволяющий котроллировать порядок, в котором элементы располагаются в коллекции, а также управлять доступом к этим элементам.

Пример некоторых контейнеров последовательностей:
- `std::vector` - динамически расширяемый массив;
- `std::array` - массив фиксированного размера;
- `std::forward_list` - односвязный список;
- `std::list` - двусвязный список;
- `std::deque` - двусторонняя очередь.

## 090 Контейнер последовательностей vector


Контейнер `std::vector` - это контейнер последовательностей, выполняющий представление расширяющегося массива элементов.

Ниже представлены некоторые методы контейнера:
```c++
T& front() // получить ссылку на первый элемент
T& back() // получить ссылку на последний элемент

void push_back(const T& element) // поместить элемент в конец
void pop_back() // удалить последний элемент

std::size_t capacity() // возвращает текущую вместительность
std::size_t size() // возвращает текущий размер

void reserve(std::size_t capacity) // выделить вместительность
void shrink_to_fit() // ужимает вместительность до размера

T& operator[](std::size_t index) // небезопасный доступ к элементам
T& at(std::size_t index) // безопасный доступ к элементам
```

_Примечание._ Подробнее про коллекцию `std::vector` можно прочитать 
[по данной ссылке](https://en.cppreference.com/w/cpp/container/vector).

## 091 Контейнер последовательностей list

Контейнер `std::list` - это контейнер последовательностей, выполняющий представление двусвязного списка в памяти.

Ниже представлены некоторые методы контейнера:
```c++
T& front() // получить ссылку на первый элемент
T& back() // получить ссылку на последний элемент

void push_front(const T& element) // поместить элемент в начале
void pop_front() // удалить первый элемент

void push_back(const T& element) // поместить элемент в конец
void pop_back() // удалить последний элемент

std::size_t size() // возвращает текущий размер массива
```

_Примечание._ Подробнее про коллекцию `std::list` можно прочитать 
[по данной ссылке](https://en.cppreference.com/w/cpp/container/list).

## 092 Контейнер последовательностей deque

Контейнер `std::deque` - это контейнер последовательностей, выполняющий представление двухсторонней очереди элементов.

Ниже представлены некоторые методы контейнера:
```c++
T& front() // получить ссылку на первый элемент
T& back() // получить ссылку на последний элемент

void push_front(const T& element) // поместить элемент в начале
void pop_front() // удалить первый элемент

void push_back(const T& element) // поместить элемент в конец
void pop_back() // удалить последний элемент

T& operator[](std::size_t index) // небезопасный доступ к элементам
T& at(std::size_t index) // безопасный доступ к элементам

std::size_t size() // возвращает текущий размер

void shrink_to_fit() // ужимает вместительность до размера
```

_Примечание_. Несмотря на то, что коллекция `std::deque` обеспечивает случайный доступ к элементам коллекции за константное время, а также схожий с `std::vector` интерфейс, ввиду наличия операций добавления и удаления элемента в начало, не обеспечивает _contiguos_-доступ к элементам. Подробнее про коллекцию `std::deque` можно прочитать 
[по данной ссылке](https://en.cppreference.com/w/cpp/container/deque).

## 093 Ассоциативные контейнеры

_Ассоциативный контейнер_ - это контейнер, который обеспечивает быстрый поиск данных, основанный на ключах.

Пример некоторых ассоциативных контейнеров:
- `std::set` - множество уникальных элементов;
- `std::multiset` - множество повторяемых элементов;
- `std::map` - ассоциативный массив уникальных элементов;
- `std::multimap` - ассоциативный массив повторяющихся элементов.

_Примечание._ Перечисленные выше примеры являются _упорядоченными ассоциативными_ контейнерами, 
[реализованными](https://en.cppreference.com/w/cpp/container#Associative_containers) 
на _бинарном дереве_. 
Для каждого из них существует _неупорядоченные ассоциативные_ контейнеры,
[реализованные](https://en.cppreference.com/w/cpp/container#Unordered_associative_containers_.28since_C.2B.2B11.29) 
на хеш-таблицах.

## 094 Ассоциативный контейнер set

Контейнер `std::set` - это ассоциативный контейнер, выполняющий представление множества уникальных элементов и предоставляющий их быстрый поиск, вставку и удаление.

_Примечание._ Подробнее про коллекцию `std::set` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/set).

## 095 Ассоциативный контейнер multiset

Контейнер `std::multiset` - это ассоциативный контейнер, выполняющий представление множества повторяющихся элементов и предоставляющий их быстрый поиск, вставку и удаление.

_Примечание._ Подробнее про коллекцию `std::multiset` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/multiset).

## 096 Ассоциативный контейнер map

Контейнер `std::map` - это ассоциативный контейнер, выполняющий представление ассоциативного массива, сопоставляющий значение уникальному ключу.

_Примечание._ Подробнее про коллекцию `std::map` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/map).

## 097 Ассоциативный контейнер multimap

Контейнер `std::multimap` - это ассоциативный контейнер, выполняющий представление ассоциативного массива, сопоставляющий набор значений уникальному ключу.

_Примечание._ Подробнее про коллекцию `std::multimap` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/multimap).

## 098 Адаптер stack

Адаптер `std::stack` - это адаптер контейнера `std::vector`, предоставляющий доступ к элементам по принципу _FILO (первый вошел - последний вышел)_.

_Примечание._ Подробнее про адаптер `std::stack` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/stack).

## 099 Адаптер queue

Адаптер `std::queue` - это адаптер контейнера `std::deque`, предоставляющий доступ к элементам по принципу _FIFO (первый вошел - первый вышел)_.

_Примечание._ Подробнее про адаптер `std::queue` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/queue).

## 100 Адаптер priority_queue

Адаптер `std::priority_queue` - это адаптер _очереди_, выполняющий упорядочивание элементов по весу и предоставляющий доступ к первому в порядке элементу.

_Примечание._ Подробнее про коллекцию `std::priority_queue` можно прочитать
[по данной ссылке](https://en.cppreference.com/w/cpp/container/priority_queue).

## 101 STL-алгоритмы

STL-алгоритмы являются одной из основных сущностей STL и представляют собой наиболее часто используемые на практике алгоритмы, которые можно применить к шаблонным типам.

Примерами таких алгоритмов являются общие для всех контейнеров алгоритмы поиска, сортировки, обмена данных, а также такие специальные алгоритмы как бинарный поиск и слияние упорядоченных последовательностей.

## 102 Алгоритмы сортировки sort

Алгоритм `sort` - алгоритм STL, выполняющий упорядочивание последовательности по заданному компаратору:
```c++
// сортировка по умолчанию (по неубыванию значений представления)
template<class RandomIt>
void sort(RandomIt first, RandomIt last);

template<class RandomIt, class Compare>
void sort(RandomIt first, RandomIt last, Compare comp);
```

Пример использования:
```c++
#include <algorithm>
#include <functional>
#include <array>
#include <iostream>
#include <string_view>
 
int main()
{
    std::array<int, 10> s = {5, 7, 4, 2, 8, 6, 1, 9, 0, 3};
 
    auto print = [&s](std::string_view const rem)
    {
        for(auto a : s){
            std::cout << a << ' ';
        }
        std::cout << ": " << rem << '\n';
    };
 
    std::sort(s.begin(), s.end());
    print("sorted with the default operator '<'");
 
    std::sort(s.begin(), s.end(), std::greater<int>());
    print("sorted with the STL compare function object");
 
    struct{
        bool operator()(int a, int b) const { return a < b; }
    }
    customLess;
 
    std::sort(s.begin(), s.end(), customLess);
    print("sorted with a custom function object");
 
    std::sort(s.begin(), s.end(), 
    [](int a, int b){
        return a > b;
    });
    print("sorted with a lambda expression");
}
```

Результат выполнения программы:
```
0 1 2 3 4 5 6 7 8 9 : sorted with the default operator '<'
9 8 7 6 5 4 3 2 1 0 : sorted with the STL compare function object
0 1 2 3 4 5 6 7 8 9 : sorted with a custom function object
9 8 7 6 5 4 3 2 1 0 : sorted with a lambda expression
```

## 103 Алгоритмы поиска find

В STL существуют следующие алгоритмы поиска:
```c++
// f - итератор на начало последовательности
// l - итератор на конец последовательности
// v - ссылка на искомое значение
// p - унарный предикат, по которому выполняется условный поиск

template<class InputIt, class T>
InputIt find(InputIt f, InputIt l, const T& v);

template<class InputIt, class UnaryPredicate>
InputIt find_if(InputIt f, InputIt l, UnaryPredicate p);

template<class InputIt, class UnaryPredicate>
InputIt find_if_not(InputIt f, InputIt l, UnaryPredicate q);
```

Пример использования:
```c++
#include <iostream>
#include <vector>
#include <algorithm>

int main(){
    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    auto it = std::find_if(v.begin(), v.end(), 
    [](auto& x){
        return x % 2 == 0 and x % 3 == 0;
    });

    if(it == v.end()){
        std::cout << "element not found" << std::endl;
    }
    else {
        std::cout << "element: " << *it << std::endl;
    }
}
```

Результат выполнения программы:
```
element: 6
```

## 104 Алгоритмы swap

Алгоритм `swap` - алгоритм STL, выполняющий обмен значений по ссылкам.

Пример использования:
```c++
#include <iostream>
#include <algorithm>

int main(){
    int a = 10;
    int b = 20;
    
    std::cout << "B: " << a << ' ' << b << std::endl;
    std::swap(a, b);
    std::cout << "A: " << a << ' ' << b << std::endl;
}
```

Результат выполнения программы:
```
B: 10 20
A: 20 10
```

Примечание. В версии C++11 была добавлена реализация `std::swap`, перегружающая `std::swap_ranged(a, a + n, b)`.

## 105 Алгоритм merge

Алгоритм `merge` - алгоритм STL, позволяющий выполнить операцию слияния двух упорядоченных последовательностей элементов в единую последовательность:

Пример использования:
```c++
#include <algorithm>
#include <functional>
#include <iostream>
#include <iterator>
#include <random>
#include <vector>
 
auto print = [](auto const rem, auto const& v)
{
    std::cout << rem;

    std::copy(v.begin(), 
              v.end(), 
              std::ostream_iterator<int>(std::cout, " "));

    std::cout << '\n';
};
 
int main()
{
    // заполняет векторы случайными числами (random C++11)
    std::random_device rd;
    std::mt19937 mt(rd());
    std::uniform_int_distribution<> dis(0, 9);
 
    std::vector<int> v1(10), v2(10);

    std::generate(v1.begin(), 
                 v1.end(), 
                 std::bind(dis, std::ref(mt)));
    
    std::generate(v2.begin(), 
                  v2.end(), 
                  std::bind(dis, std::ref(mt)));
 
    print("Originally:\nv1: ", v1);
    print("v2: ", v2);
 
    std::sort(v1.begin(), v1.end());
    std::sort(v2.begin(), v2.end());
 
    print("After sorting:\nv1: ", v1);
    print("v2: ", v2);
 
    // слияние векторов
    std::vector<int> v3;
    std::merge(v1.begin(), v1.end(), 
               v2.begin(), v2.end(), 
               std::back_inserter(v3));
 
    print("After merging:\nv3: ", v3);
}
```

Результат выполнения программы:
```
Originally:
v1: 2 6 5 7 4 2 2 6 7 0
v2: 8 3 2 5 0 1 9 6 5 0
After sorting:
v1: 0 2 2 2 4 5 6 6 7 7
v2: 0 0 1 2 3 5 5 6 8 9
After merging:
v3: 0 0 0 1 2 2 2 2 3 4 5 5 5 6 6 6 7 7 8 9
```

## 106 Алгоритм for_each

Алгоритм `for_each` - алгоритм STL, позволяющий применить унарную функцию по отношению к элементам некоторой последовательности.

Пример использования:
```c++
#include <vector>
#include <algorithm>
#include <iostream>
 
struct Sum
{
    void operator()(int n) { sum += n; }
    int sum{0};
};
 
int main()
{
    std::vector<int> nums{3, 4, 2, 8, 15, 267};
 
    auto print = [](const int& n) { std::cout << " " << n; };
 
    std::cout << "before:";
    std::for_each(nums.cbegin(), nums.cend(), print);
    std::cout << '\n';
 
    // вызывает Sum::operator() для каждого числа
    Sum s = std::for_each(nums.begin(), nums.end(), Sum());
    
    std::cout << "sum: " << s.sum << '\n';
}
```

Результат выполнения программы:
```
before: 3 4 2 8 15 267
sum: 299
```

## 107 Лямбда функции

_Лямбда-функция_ - специальный синтаксис для определения функциональных объектов, заимствованный из $\lambda$-исчисления. Применяется как правило для объявления анонимных функций по месту их использования, и обычно допускает замыкание на лексический контекст, в котором это выражение использовано.

В языке С++ лямбда-функции определяются следующим образом:
```c++
 [capture](args)specificator exception_specificator -> type {body}
```

`capture` - "захват", отвечает за то, какие данные и каким образом будут доступны в теле лямбда выражения. 

Режим записи по умолчанию можно использовать для указания способа записи любых внешних переменных, на которые ссылается текст лямбда-выражения: 
- [&] означает, что все переменные, на которые вы ссылаетесь, фиксируются по ссылке
- [=] означает, что они фиксируются по значению.

`args` - принимаемые лямбда-функцией аргументы.

`specificator` - изменяемая спецификация (например: mutable), является доп. параметром.

`exception_specificator` - спецификация исключения, дополнительный параметр.

`type` - возвращаемое значение функции.

`body` - тело лямбда-функции.

## 108 Конструктор перемещения

_Конструктор перемещения_ реализует _move-семантику_, упомянутую в _пункте 29_, и позволяет перемещать ресурсы, принадлежащие _rvalue_, в _lvalue_ без копирования.

Пример:
```c++
#include <iostream>

class Data {
public:
    explicit Data(){
        id = current_id++;
        std::cout << "Constructor "
                  << id << std::endl;
    }

    Data(const Data& other){
        id = current_id++;
        std::cout << "Copy constructor "
                  << other.id << " -> " << id << std::endl;
    }

    Data(const Data&& other) noexcept {
        id = current_id++;
        std::cout << "Move constructor "
                  << other.id << " -> " << id << std::endl;
    }

    ~Data(){
        std::cout << "Destructor "
                  << id << std::endl;
    }

private:
    static int current_id;
    int id;
};

int Data::current_id = 0;

int main(){
    Data a;                 // id 0
    Data b(a);              // id 1
    Data c(std::move(b));   // id 2
}
```

Результат выполнения программы:
```
Constructor 0
Copy constructor 0 -> 1
Move constructor 1 -> 2
Destructor2
Destructor1
Destructor0
```

В данном примере происходит следующее:
1. создается экземпляр 0;
2. создается экземпляр 1 копированием данных экземпляра 0;
3. создается экземпляр 2 переносом данных экземпляра 1;
4. вызывается деструктор для экземпляра 2;
5. вызывается деструктор для экземпляра 1;
6. вызывается деструктор для экземпляра 0.

_Примечание._ Пункт (5) последовательности действий никак не противоречит _move-семантике_: переносится не объект, а его данные, т.е., объект не уничтожается, а принимает другое состояние, не содержащее свои прежние данные.

## 109 Оператор присваивания перемещения

Оператор присваивания перемещения имеет семантику, похожую на _конструктор перемещения_, описанный в _пункте 108_, но в отличие от него вызывается не при создании объекта, а в случаях присваивания _rvalue_ уже существующему _lvalue_.

## 110 Паттерны проектирования

_Паттерны проектирования_ - способы решения типовых задач при проектировании программы.

Паттерны проектирования обычно делятся на:
- Порождающие (фабричный метод, абстрактная фабрика, одиночка и др.)  - отвечают за удобное и безопасное создание новых объектов или даже целых семейств объектов.
- Структурные (адаптер, мост декоратор, заместитель и др.) - отвечают за построение удобных в поддержке иерархий классов.
- Поведенческие (итератор, наблюдатель, стратегия и др.) - решают задачи эффективного и безопасного взаимодействия между объектами программы.

## 111 Паттерн "Абстрактная фабрика"

_Абстрактная фабрика_ — это порождающий паттерн проектирования, который позволяет создавать семейства связанных объектов, не привязываясь к конкретным классам создаваемых объектов.

Пример:
```c++
#include <iostream>

class Shape {
public:
    virtual void draw() = 0;
    virtual ~Shape() = default;
};

class Circle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing circle instance" << std::endl;
    }
};

class Square : public Shape {
public:
    void draw() override {
        std::cout << "Drawing square instance" << std::endl;
    }
};

class Ellipse : public Shape {
public:
    void draw() override {
        std::cout << "Drawing ellipse instance" << std::endl;
    }
};

class Rectangle : public Shape {
public:
    void draw() override {
        std::cout << "Drawing rectangle instance" << std::endl;
    }
};

class Factory {
public:
    virtual ~Factory() = default;
    // создает изогнутую фигуру
    virtual Shape* create_curved_instance() = 0;    
    // создает прямую фигуру
    virtual Shape* create_straight_instance() = 0; 
};

// создает произвольные фигуры
class SimpleShapeFactory : public Factory {
public:
    Shape* create_curved_instance() override {
        return new Ellipse;
    }

    Shape* create_straight_instance() override {
        return new Rectangle;
    }
};

// создает простые фигуры
class RobustShapeFactory : public Factory {
public:
    Shape* create_curved_instance() override {
        return new Circle;
    }

    Shape* create_straight_instance() override {
        return new Square;
    }
};

int main(){
    Factory* factory;
    Shape* shapes[6];

    factory = new SimpleShapeFactory;
    shapes[0] = factory->create_curved_instance();
    shapes[1] = factory->create_straight_instance();
    shapes[2] = factory->create_curved_instance();

    delete factory;

    factory = new RobustShapeFactory;
    shapes[3] = factory->create_curved_instance();
    shapes[4] = factory->create_straight_instance();
    shapes[5] = factory->create_curved_instance();

    for(auto& shape : shapes){
        shape->draw();
    }
}
```

Результат выполнения программы, реализующей паттерн _Абстрактная фабрика_:
```
Drawing ellipse instance
Drawing rectangle instance
Drawing ellipse instance
Drawing circle instance
Drawing square instance
Drawing circle instance
```

## 112 Умные указатели

_Умные указатели_ - абстрактный тип данных, обеспечивающий безопасное управление памятью.

В С++ существует три типа умных указателей:
- `std::unique_ptr` — умный указатель, владеющий динамически выделенным ресурсом;
- `std::shared_ptr` — умный указатель, владеющий разделяемым динамически выделенным ресурсом. Несколько `std::shared_ptr` могут владеть одним и тем же ресурсом, и внутренний счетчик ведет их учет;
- `std::weak_ptr` — подобен `std::shared_ptr`, но не увеличивает счетчик.

Умные указатели определены в заголовочном файле стандартной библиотеки `<memory>`.

### unique_ptr
`std::unique_ptr` владеет объектом на который он указывает и никакие другие умные указатели не могут на него указывать. 

Когда `std::unique_ptr` выходит из области видимости, объект удаляется.

Пример создания `std::unique_ptr`:

```c++
// создание обычным способом
std::unique_ptr<Type> p(new Type);

// создание с помощью функции make_unique
std::unique_ptr<Type> p = std::make_unique<Type>(params);
```

### shared_ptr

`std::shared_ptr` владеет объектом, на который он указывает, но, в отличие от `std::unique_ptr`, допускает множественные ссылки.

Специальный внутренний счетчик уменьшается каждый раз, когда `std::shared_ptr`, указывающий на тот же ресурс, выходит из области видимости. Эта техника называется подсчетом ссылок. Когда последняя из них будет уничтожена, счетчик станет равным нулю и данные будут высвобождены.

Пример создания `std::shared_ptr`:

```c++
// создание обычным способом
std::shared_ptr<Type> p(new Type);

// создание с помощью функции make_shared
std::shared_ptr<Type> p = std::make_shared<Type>(params);
```

Для получения значения счётчика указателя `std::shared_ptr` используется метод `use_count()`.

### weak_ptr

Шаблон класса описывает объект, указывающий на ресурс, управляемый одним или несколькими `shared_ptr` объектами. 

Объекты `weak_ptr` , указывающие на ресурс, не влияют на число ссылок ресурса. 

При уничтожении последнего `shared_ptr` объекта, который управляет этим ресурсом, ресурс будет освобожден, даже если есть объекты, указывающие weak_ptr на этот ресурс. Это важно для предотвращения циклов в структурах данных.

```c++
std::shared_ptr<int> p_shared = std::make_shared<int>(100);

std::weak_ptr<int> p_weak1(p_shared); // через shared_ptr
std::weak_ptr<int> p_weak2(p_weak1); // через weak_ptr
```
